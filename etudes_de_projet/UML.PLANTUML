@startuml
class Pile {
  -exps : Expression *
  -nb: size-t
  -nbMax; size-t
  -nbAffiche: size-t
  -message : string 
  +void AgrandissementCapacite ()
  +Pile() 
  +void Affiche () const
  +void push ()
  +void pop ()
  +bool estVide () const
  +size-t estvide () const
  +Expression& top () const 
  +void SetMessage (const )
  +string getMessage () const 
  +void setnbitemstoaffiche ()
  ~Pile ()
}
note top 
singleton , choisir le mode d'implémentation
end note

class ExpressionManager {
    Expression** exps
    size_t nb
    size_t nbMax

    ExpressionManager()
    ~ExpressionManager()
    
    struct Handler {
        ExpressionManager* instance
        Handler()
        ~Handler()

    };
    static Handler handler;

public:
    Expression& addExpression(Expression& e);
    void removeExpression(Expression& e);
    void agrandissementCapacite();
    static ExpressionManager& getInstance();
    void libereinstance();
}
note top 
est ce qu expressionmanager peut ajouter une expression, c'est à dire
en créer une nouvelle? On a aussi les Varmanager et Progmanager qui vont gérer
les nouvelles expressions, et le reste des expressions sont prédéfinies?

 * avons nous besoin d'un iterator pour cette classe?
 * Puisqu'on aura des iterator pour varmanager et prog manager?

end note




class Interface {
}

class Observer {
  
}
note top 
fait le lien entre engine et interface
end note
Observer -- Pile : < communique avec
Observer -- VariableManager : < communique avec
Observer -- ProgrammeManager : < communique avec
Observer -- Interface : < communique avec






class Expression{
void SetExpression(Expression& o)
Expression& GetExpression()
void raz() //détruit une opérande.
}
note top 
encapsule les littérales et les operateurs 
end note 
Expression <|-- Litterale
Expression <|-- Operateur
Expression <|-- UserVar
Expression <|-- UserProg






class Operateur {
}
class OperateurBinaire {
}
class OperateurUnaire {
}
class OperateurNaire {
}
Operateur <|-- OperateurBinaire 
Operateur <|-- OperateurUnaire 
Operateur <|-- OperateurNaire




class ComputerException {
  +info: string
  +ComputerException
  +string getInfo() const
}





class Litterale{
}

class Lprogramme{}
class Lnumerique{}

class Lentiere {
int value
}

class Lreelle{
float value
}
class Lrationnelle{
int numerateur; 
int denominateur; 
}
class Lexpression{}
class Latome {}





class UserVar{
Latome* id; 
}
class UserProg{
Latome* id; 
}
class VariableManager { 
UserVar** tab
}
class ProgrammeManager { 
UserProg** tab
} 
VariableManager "1" *-- "*"UserVar
ProgrammeManager "1" *-- "*"UserProg






ExpressionManager "1" *-- "0..*" Expression
Pile "1" *-- "0..*" Expression
Litterale <|--  Lprogramme
Litterale <|--  Lnumerique
Litterale <|--  Lexpression
Litterale <|-- Latome
Lnumerique <|--  Lentiere
Lnumerique <|--  Lreelle
Lnumerique <|--  Lrationnelle
@enduml
