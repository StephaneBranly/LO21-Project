@startuml
package Engine {

class ComputerEngine {
  - stack : Stack
  - expressionManager : ExpressionManager
  - atomManager : AtomManager
  - {static} hand : Handler
  + ComputerEngine()
  + getStack() : Stack&
  + getExpressionManager() : ExpressionManager&
  + getAtomManager() : AtomManager&
  + {static} getInstance() : ComputerEngine&
} 

class Handler{
  + instance : ComputerEngine*
  + ~Handler()
}

package Stack {
class Stack {
  - items : vector<Expression*>
  + Stack()
  + ~Stack()
  + push(item : Expression*)
  + clear()
  + swap()
  + pop() : Expression*
  + isEmpty() const : bool
  + size() const : size_t
  + top() const : Expression*
  + toStringList : list<string>
}
}

package Expression {
class ExpressionManager {
  - exps : list<Expression*>
  - factory : ExpressionAbstractFactory*
  + ExpressionManager()
  + evalCommandLine(str : const string)
  + split(text : const string&, delimiter : char) : vector<string>
  + createExpressionFromString (s : const string) : Expression*
  + getFactory() : ExpressionAbstractFactory*
  + ~ExpressionManager()
}

class ExpressionFactory {
  + ExpressionFactory
  + {virtual} isSameType(s : const string) const : bool
  + {virtual} createExpressionFromString(s : const string) : Expression*
}

class ExpressionAbstractFactory {
  - operatorFactory : OperatorFactory*
  - factories : list<ExpressionFactory*>
  + ExpressionAbstractFactory()
  + createExpressionFromString(s : const string)
  + registerFactory(factory : ExpressionFactory*)
  + getOperatorFactory() const : OperatorFactory*
}

class Expression {
  # type : string
  + {virtual} eval()
  + {virtual} toString() const : const string 
  + {virtual} getType() const : const string
  + {virtual} getCopy() const : Expression*
  + Expression()
  + Expression(type : const string)
  + {virtual} ~Expression()
}

class AtomManager {
  - atoms : map<string, Expression*> 
  + alreadyExists(name : const string) : bool
  + getExpressionFromAtom(a : const Latom*) : Expression*
  + getExpressionFromString(s : const string) : Expression*
  + removeAtom(name : const string)
  + addAtom(name : const string, expression : Expression*)
}

package Operator {
class Operator {
  - arrity : size_t
  + {virtual} getArrity() const : size_t
  + {virtual} executeOpe()
  + eval()
  + {virtual} getCopy() const : Expression*
}

class OperatorFactory {
  - operators : map<string, Operator*>
  + isSameType(s : const string) const : bool
  + createExpressionFromString(s : const string) : Expression*
  + addOperator(name : const string, ope : Operator*)
  + removeOperator(name : const string)
}

class OperatorCLEAR {
  - arrity : size_t
  - type : string
  + getArrity() const : size_t
  + executeOpe()
  + getType() const : const string
  + toString() const : const string
  + getCopy() const : Expression*
}

class OperatorSWAP {
  - arrity : size_t
  - type : string
  + getArrity() const : size_t
  + executeOpe()
  + getType() const : const string
  + toString() const : const string
  + getCopy() const : Expression*
}

class OperatorDROP {
  - arrity : size_t
  - type : string
  + getArrity () const : size_t
  + void executeOpe()
  + getType() const : const string
  + toString() const : const string
  + getCopy() const : Expression*
}

class OperatorDUP {
  - arrity : size_t
  - type : string
  + getArrity() const : size_t
  + executeOpe()
  + getType() const : const string
  + toString() const : const string
  + getCopy() const : Expression* 
}
}

package Litterales {
class Latom {
  - atom : string
  # type : string
  + Latom(s : const string)
  + Latom(const Latom&)
  + setLatom(s : const string) : Latom*
  + getValue() const : string
  + getType() const : const string
  + eval()
  + toString() const : const string 
  + getCopy() const : Expression*
}

class LatomFactory {
  + isSameType(s : const string) const : bool
  + createExpressionFromString(s : const string) : Latom*
}

class Lexpression {
  - expression : string
  # type : string
  + Lexpression(s : const string)
  + setLatom(s : const string) : Lexpression*
  + getValue() : string
  + getType() const : const string
  + eval()
  + toString() const : const string
  + getCopy() const : Expression*
}

class LexpressionFactory {
  + isSameType(s : const string) const : bool
  + createExpressionFromString(s : const string) : Lexpression*
}

class Linteger {
  - value : int
  # type : string
  + Linteger(s : const string)
  + Linteger(const Linteger&)
  + Linteger(v : int)
  + setLinteger(v : int) : Linteger*
  + getvalue() : int
  + toString() const : const string
  + getType() const : const string
  + getCopy() const : Expression*
}

class LintegerFactory {
  + isSameType(s : const string) const : bool
  + createExpressionFromString(s : const string) : Linteger*
}

abstract class Lnumerical {
  + eval()
}

class Lprogram {
  + Lprogram()
}

class Lrational {
  - numerateur : int
  - denominateur : int
  - simplify()
  - PGCD(a : int, b : int) : int
  # type : string
  + Lrational(n : int, d : int)
  + setRational(n : int, d : int)
  + setRational(e1 : Linteger&, e2 : Linteger&)
  + toString() const : const string
  + getType() const : const string
  + getCopy() const : Expression*
}

class Lreal {
  - real : float
  # type : string
  + Lreal(s : const string)
  + Lreal(r : float)
  + setReal(r : float) : Lreal*
  + toString() const : const string
  + getType() const : const string
  + getCopy() const : Expression*
}

class LrealFactory {
  + isSameType(s : const string) const : bool
  + createExpressionFromString(s : const string) : Lreal*
}
}
}

package Exception {
class ComputerException {
  - info : string
  + ComputerException(str : const string&)
  + getInfo() const : string
}
}



Subject <|-- ComputerEngine
Expression <|-- Operator
Expression <|-- Latom
Expression <|-- Lexpression
Expression <|-- Lnumerical
Expression <|-- Lprogram
ExpressionFactory <|- OperatorFactory
ExpressionFactory <|- LatomFactory
ExpressionFactory <|- LexpressionFactory
ExpressionFactory <|-- LintegerFactory 
ExpressionFactory <|-- LrealFactory
Operator <|-- OperatorCLEAR
Operator <|-- OperatorSWAP
Operator <|-- OperatorDROP
Operator <|-- OperatorDUP
Lnumerical <|-- Linteger
Lnumerical <|-- Lrational
Lnumerical <|-- Lreal



ComputerEngine o-- Handler


}
@enduml
